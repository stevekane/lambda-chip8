f := [(0,0), (1,1), (2,2)]
g := [(1,45)]
h := [(0,0), (1,45), (2,2)]

for all values c in the domain of g, h(c) = g(c)
for all values c not in the domain of g, h(c) = f(c)

h(x) = | g(x), x ∈ domain(g)
       | f(x), otherwise

In other words, if we have three functions we can ask
if h satisfies some relationship to f and g

relationship(f,g,h) := 
  ∀x ∈ domain(h) 
    ∨ x ∈ domain(g) ∧ h(x) = g(x)
    ∨ x ∈ domain(f) ∧ f(x) = f(x)

existence(f,g) :=
  ∃h ∈ domain(f) ∪ domain(g) → codomain(f) ∪ codomain(g)
  ∀x ∈ domain(h)
    ∨ x ∈ domain(g) ∧ h(x) = g(x)
    ∨ x ∈ domain(f) ∧ h(x) = f(x)

existence(f,g) :=
  let 
    a := domain(f)
    b := domain(g)
    c := a ∪ b
    d := codomain(f)
    e := codomain(g)
    f := d ∪ e
  in
    ∃h ∈ c → f :
      ∨ x ∈ b ∧ h(x) = g(x)
      ∨ x ∈ a ∧ h(x) = f(x)

-- symmetric difference
a △ b = (a ∪ b) - (a ∩ b)

-- predicate verifying this type is habitable
existence(F,G) :=
  let 
    A := domain(F)
    B := domain(G)
    C := A ∪ B
    D := A △ B
    E := C ∪ D
    R := codomain(F)
    S := codomain(G)
    T := (R ∪ S) ∪ (R △ S)
  in
    ∃H ∈ [E → T] :
      ∨ X ∈ D ∧ H(X) = G(X)
      ∨ X ∈ E ∧ H(X) = F(X)

Let's sanity-check ourselves here:

We can define a vector as <0,1> and we can think of it as being short-hand for
a function from {0,1} → {0,1}. Additionally, we could think of this as being 
short-hand for a a function from {0,1} → N or B → B. We need to say what this 
vector actually IS by specifying the types of the domain and codomain.

a : {0,1,2,3} → N = <0,1,2,3>

Let's say we now have a second vector:

b : {0,1} → N = <4,5>

What would it mean to produce a new function by "overlaying b on top of a"?

In set theory, we could say that the new domain is {0,1,2,3} U {0,1} which is {0,1}
In type theory, we might be temped to say that we can translate this to a sum type.
This is not true though because the sum is analogous to the disjoint-union under
Curry-Howard but we do not have a disjoint union to consider here.

f : A → C
g : B → D
h : L + M + N → C + D

We need to know what the types L N and M are. They must be disjoint as mentioned.
We know that the resulting function should contain three domains: Type of values
only found in A. Type of values only found in B. Type of values found in both A
and B.

**ASIDE** 
It seems dubious to talk about values that are "elements of multiple types".
The whole idea of type theory is that terms are always members of some specific type.
We could for example say 1 : B AND 1 : N but the "1" in these two types has no 
relationship with each other by virtue of "one-ness". Instead, we could define
a mapping BETWEEN the two types that somehow created this relationship:

  m : B → N, m(0) = 0, m(1) = 1


Here are formal correspondences from CH to type theory and some derivation rules.

  Logic:
    Natural: A implies A or B.
    Formal:  A ⇒ (A ∨ B)
  Types: 
    Natural: A is a subtype of the sum of A and B.
    Formal:  A <= A + B

  Logic:
    Natural: B implies A or B.
    Formal:  B ⇒ (A ∨ B)
  Types: 
    Natural: B is a subtype of the sum of A and B.
    Formal:  B <= (A + B)

  Logic:
    Natural: A and B implies A.
    Formal:  (A ∧ B) ⇒ A
  Types: 
    Natural: The product of A and B is a subtype of A.
    Forma: (A × B) <= A

  Logic:
    Natural: A and B implies B.
    Formal:  (A ∧ B) ⇒ B
  Types: 
    Natural: The product of A and B is a subtype of B.
    Formal:  (A × B) <= B

  Logic: 
    Natural: A implies B and A implies C implies A implies B and C.
    Formal:  ((A ⇒ B) ∧ (A ⇒ C)) ⇒ (A ⇒ (B ∧ C))
  Types: 
    Natural: A is a subtype of B and A is a subtype of C introduces
             A is subtype of the product of B and C.
    Formal:  ((A <= B) × (A <= C)) → (A <= (B × C))

  Logic:
    Natural: A implies C and B implies C implies A or B implies C.
    Formal:  ((A ⇒ C) ∧ (B ⇒ C)) ⇒ ((A ∨ B) ⇒ C)
  Types:
    Natural: A is a subtype of C and B is a subtype of C introduces
             the sum of A and B is a subtype of C.
    Formal:  ((A <= C) × (B <= C)) → ((A + B) <= C)


  A → (A ∨ B) ⇒ CurryHoward ⇒ A <= A + B
  B → (A ∨ B) ⇒ CurryHoward ⇒ B <= A + B
  (A ∧ B) → A ⇒ CurryHoward ⇒ A × B <= A
  (A ∧ B) → B ⇒ CurryHoward ⇒ A × B <= B

  (A <= B) → (A <= C) → (A <= (B × C))